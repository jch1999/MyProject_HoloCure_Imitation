#pragma once
class Weapon :public Skill
{
public:
	enum class WEAPON_TYPE
	{
		MULTI_SHOT,		// 다중 발사형 - 갯수 증가에 영향을 받음
		RANGE,			// 단순 발사형
		MELEE			// 근접 공격형
	}weaponType;

protected:
	// 투사체의 설정값이 레벨에 상관없이 일정할 때 사용.
	float projDelay;
	float nowProjDelay;
	float projSpd;
	int projCnt;
	float hitCooldown;

	// level 당 데미지, 콜라이더 index
	vector<float> minDamageTable;
	vector<float> maxDamageTable;
	vector<int> colliderIdxTable;

	// level 당 투사체 수, 투사체의 hit 제한수, 공격 딜레이, 생존시간
	vector<float> projCntTalbe;
	vector<float> projDelayTable;
	vector<float> projSpdTable;
	vector<int> hitLimitTable;
	vector<float> delayTable;
	vector<int> ricochetTable;
	vector<float> projLifetimeTable;

	// 무기에서 사용하는 projectile
	vector<Projectile*> projectiles;
	vector<int> ricochetCnt; // 각 탄환의 도탄횟수
	//임시 생성
	//vector<set<Enemy*>> hitEnemies; // 중복 충돌을 막기 위해 충도한 에너미의 정보를 저장

public:
	Weapon(SKILL_ID id,int maxLevel=7);
	virtual ~Weapon();
	
	virtual void Update() = 0;
	virtual void Render() = 0;
	virtual void PostRender() = 0;

	virtual bool LevelUp() = 0;
	virtual bool GetEnhanceAble() { return true; }
	virtual bool Enhance();

	template <typename T>
	inline T* GetProjectTile()
	{
		T* proj = nullptr;
		for (int i = 0; i < projectiles.size(); i++)// 비활성화 상태인 총알 하나를 찾아 사용
		{
			if (projectiles[i]->is_active == false)
			{
				proj = dynamic_cast<T*>(projectiles[i]);
				break;
			}
		}

		// 비활성 상태 Tear 없음 == Tear가 부족함 -> 새로 생성
		if (proj == nullptr)
		{
			proj = new T();
			projectiles.push_back(proj);
			dynamic_cast<Projectile*>(proj)->SetOwner(this);
		}

		return proj;
	}
};
